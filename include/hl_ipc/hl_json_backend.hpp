/******************/

#include <stack>
#include <vector>
#include <string>
#include "../throw.hpp"
#include <json/json.h>

#if defined (INSTANTIATION_WORK)
    #include <hl/include/if.hpp>
    #include <hl/include/hl_ipc/conversion_json_base.hpp>
    #include <hl/include/any2str.hpp>
    // #include <hl/include/hl_ipc/ls_error.hpp>
#else
    #include "../if.hpp"
    #include "../hl_ipc/conversion_json_base.hpp"
    #include "../any2str.hpp"
    // #include "../hl_ipc/ls_error.hpp"
#endif

namespace hl
{
    template <typename Type>
    void inline
    lg_assert(Type o, char const* ss, char const* in__, int line__)
    {
        if (!o)
            hl::std_throw_(((((std::string(ss) + " != true, line: ")
                    + (hl::any2str() << line__).str() + " in \"") + in__) + "\""));
    }
}

#define LG_ASSERT(o) \
        hl::lg_assert(o, #o, __PRETTY_FUNCTION__, __LINE__)

namespace hl
{
// Foreighn declaration about backend converters
template <typename To>
struct conversion;

//
// This is tag type to specialize logic
struct json_backend_tag_type;

//     This type is a json back-end which used in hl::Interface
// It can be changed.
template <typename StringType
        , typename Invoker>
struct JsonBackend : Invoker
{
    //
    // This tag should use in conversion
    // also in specifying the sendign algoritm
    typedef json_backend_tag_type tag_type;

    //
    //  Type of backend tyo accessing from external
    // functional scope
    typedef JsonBackend backend_type;

    virtual ~JsonBackend()
    {    }

    // This is formatter class
    // The instance of it will created in the Interface
    // It should be suitable to used as template parameter
    template <typename Service, typename Accessor>
    struct json_format
    {
        typedef Service service_type;
        typedef Accessor accessor_type;

        // This is to calling
        json_format()
            :objects_()
            , uri_((StringType(Service::uri()) + "/") + accessor_type::functionName())
            , args_()
            , return_value_()
            , isfirst_(true)
        {}

        // This is to calling
        json_format(StringType const& uri, StringType const& func)
            :objects_()
            , uri_((uri + "/") + func)
            , args_()
            , return_value_()
            , isfirst_(true)
        {}

        // This is to parse return value
        json_format(StringType const& returnValue)
            :objects_()
            , args_()
            , return_value_(returnValue)
            , isfirst_(true)
        {
#ifdef LOGABLE
            std::cout << "return : " << returnValue.c_str() <<std::endl;
#endif
            this->set_result(returnValue);
        }

        ~json_format()
        {
            this->clear_stack();
        }

        bool empty ()
        {
            return objects_.empty();
        }

        void clear_stack()
        {
            // Clear stack
            if (!objects_.empty())
            {
                json_object_put(objects_.begin()->second);
                objects_.clear();
            }
        }

        void clear() {
            isfirst_ = true;
            args_ = "";
            return_value_ = "";
        }

        void set_result(StringType payload)    {
            return_value_ = payload;

            // if objects was generated by calling, we need to clean
            if (!objects_.empty())
                this->clear_stack();

            if (isempty(return_value_))
                return ;

            json_object* obj = json_tokener_parse(str_2cchar(payload));

            LG_ASSERT(obj && !is_error(obj));
            // make to object
            objects_.push_back(std::make_pair(StringType(), obj));
        }

        operator StringType()
        {
            args_ = json_object_to_json_string(get_obj());
            return args_;
        }

#        if defined(IMPL)

        static inline char const*
        str_2cchar(WTF::String const& str) {
            return str.utf8().data();
        }

        static inline bool
        isempty(WTF::String const& str) {
            return str.isEmpty();
        }

#        endif

        static inline char const*
        str_2cchar(std::string const& str) {
            return str.c_str();
        }

        static inline bool
        isempty(std::string const& str) {
            return str.empty();
        }

#if defined(WEBOS_TASKONE) || defined(WEBOS_DESKTOP)
        static inline char const*
        str_2cchar(const WTF::String& str)  {
            return str.utf8().data();
        }
        static inline bool
        isempty(const WTF::String& str) {
            return str.isEmpty();
        }
#endif

        // This is a convertion sector
        // It can be changed to any other design
        template <typename Value>
        inline json_object*
        v2obj(Value const& v)
        {
            // We should have possibility
            // to convert from external modules
            // the type isn't exposed in convertion
            // Get the type qwhisch suitable to convert this two types
            typedef typename
                hl::if_c<hl::is_converter<hl::conversion<Value> >::value
                            , hl::conversion<Value>
                            , conversion_json_base
                        >::type converter_type;

            return hl::conversion<Value>::convert(v);
        }

        template <typename Value>
        inline void
        obj2v(json_object* json, Value& v)
        {
            // Get the type qwhisch suitable to convert this two types
            typedef typename
                    hl::if_c<hl::is_converter<hl::conversion<Value> >::value
                                , hl::conversion<Value>
                                , conversion_json_base
                            >::type converter_type;

            // This place we should convert data
            hl::conversion<Value>::convert(json, v);
        }

        // This used in Interface
        int begin_array(StringType const& name
                    , unsigned int size, bool read = false)    {
            if (!read)    {
                json_object *json = json_object_new_array();
                objects_.push_back(std::make_pair(name, json));
            } else {
                // Taking
                json_object *json = json_object_object_get(get_obj(), this->str_2cchar(name));
                LG_ASSERT(json && (json_type_array == json_object_get_type(json)));

                objects_.push_back(std::make_pair(name, json));
                return json_object_array_length(json);
            }
            return 0;
        }

        void end_array(bool read = false)    {
            // If this is in a reading we have
            // to skip add to parent
            this->end_object(read);
        }

        void begin_object(StringType const& label, bool read = false)
        {
            if (read)
            {
                objects_.push_back(std::make_pair(str_2cchar(label)
                        , json_object_object_get(get_obj(), str_2cchar(label))));
                return ;
            }

            objects_.push_back(std::make_pair(label, json_object_new_object()));
        }

        // This is function will used to create array
        void begin_object(int I, bool read = false)
        {
            // This is place where we taking the array value from
            LG_ASSERT(read
                    && this->get_obj()
                    && json_object_get_type(this->get_obj()) == json_type_array);

            objects_.push_back(std::make_pair(str_2cchar(StringType(""))
                        , json_object_array_get_idx(this->get_obj(), I)));
        }

        void end_object(bool read = false)
        {
            std::pair<StringType, json_object*> obj = objects_.back();
            objects_.pop_back();

            if (!read)
            {
                // Add object to parent
                if (!objects_.empty())
                    this->add_obj_2obj(obj.first, obj.second);
            }
        }

        void flush()
        {
            if (this->get_obj())
                args_ = json_object_to_json_string(get_obj());
        }

        char const *
        get_args()
        {
            if (this->isempty(args_))
                this->flush();
            return this->str_2cchar(args_);
        }

        char const *
        get_uri()
        {    return this->str_2cchar(uri_);    }

        json_object* get_obj() {
            if (objects_.empty())
                return 0;

            return objects_.back().second;
        }

        inline void
        add_obj_2obj(StringType const& name, json_object* obj)
        {
            switch (json_object_get_type(this->get_obj()))
            {
            case json_type_object:
                json_object_object_add(this->get_obj()
                            , str_2cchar(name), obj);
                break;
            case json_type_array:
                LG_ASSERT(!name.length());
                json_object_array_add(this->get_obj(), obj);
                break;
            default:
                LG_ASSERT(false);
            }
        }

        template <typename Value>
        inline void
        add_arg(StringType const& n, Value& v)    {
            this->add_obj_2obj(n, v2obj(v));
        }

        template <typename Value>
        inline json_format&
        operator << (std::pair<StringType, Value&> v)
        {
            this->add_arg(v.first, v.second);
            return (*this);
        }

        // serialize to named value
        template <typename Value>
        inline json_format&
        operator >> (std::pair<StringType, Value&> const& v)
        {
            this->obj2v(json_object_object_get(get_obj(), str_2cchar(v.first))
                    , v.second);
            return *this;
        }

        // serialize to array Item
        template <typename Value>
        inline json_format&
        operator >> (std::pair<int, Value&> const& v)
        {
            // This is place where we taking the array value from
            LG_ASSERT(this->get_obj()
                    && json_object_get_type(this->get_obj()) == json_type_array);

            this->obj2v(json_object_array_get_idx(this->get_obj(), v.first)
                                        , v.second);
            return *this;
        }

        std::deque<std::pair<StringType, json_object*> > objects_;
        StringType uri_;
        StringType args_;
        StringType return_value_;
        bool isfirst_;
    };

    // This type will use to format
    template <typename Service, typename Accessor>
    struct Archive
    {
        typedef json_format<Service, Accessor> type;
    };

    // This a return value from which we can serialize
    typedef StringType result_type;
};
}
